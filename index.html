<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>FLAP â€” Cross-Device E2EE Social (Client)</title>
<style>
:root{--bg:#0b0f12;--card:#0f1720;--muted:#9aa5b1;--accent:#6ee7b7;--glass: rgba(255,255,255,0.03);--glass-2: rgba(255,255,255,0.02);}*{box-sizing:border-box}html,body{height:100%}body{margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;background:linear-gradient(180deg,#071018 0%, #08131a 100%);color:#e6eef3;display:flex;flex-direction:column}
.header{display:flex;align-items:center;gap:12px;padding:12px 16px;border-bottom:1px solid rgba(255,255,255,0.03)}.brand{display:flex;align-items:center;gap:10px;font-weight:700}.logo{width:40px;height:40px;border-radius:10px;background:linear-gradient(135deg,var(--accent),#4dd0e1);display:flex;align-items:center;justify-content:center;color:#062022;font-weight:700}
.container{display:flex;flex:1;gap:12px;padding:12px}
.sidebar{width:240px;min-width:160px;display:flex;flex-direction:column;gap:8px}
.main{flex:1;display:flex;flex-direction:column}
.feed{flex:1;overflow:auto;padding:8px;display:flex;flex-direction:column}
.card{background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);padding:12px;border-radius:12px;margin-bottom:10px;border:1px solid rgba(255,255,255,0.02)}
.composer textarea{width:100%;min-height:64px;background:transparent;border:none;color:inherit;resize:vertical}
.btn{background:var(--glass);padding:8px;border-radius:10px;border:1px solid rgba(255,255,255,0.02);cursor:pointer}
.small{font-size:13px;color:var(--muted)}
.ch-list{display:flex;flex-direction:column;gap:6px}
.ch-item{padding:8px;border-radius:8px;cursor:pointer}
@media (max-width:900px){.container{flex-direction:column}.sidebar{order:2;width:100%}.main{order:1}}
</style>
</head>
<body>
<div class="header">
  <div class="brand"><div class="logo">FL</div>FLAP</div>
  <input id="search" placeholder="Search" style="flex:1;padding:8px;border-radius:10px;background:var(--glass-2);border:1px solid rgba(255,255,255,0.02);color:inherit" />
  <div class="btn" id="syncStatus">sync:offline</div>
</div>
<div class="container">
  <div class="sidebar">
    <div class="card">
      <div class="small">Account</div>
      <div id="accBox"></div>
      <div style="margin-top:8px;display:flex;gap:8px"><div class="btn" id="openLogin">Login</div><div class="btn" id="keyMgmt">Keys</div></div>
    </div>
    <div class="card">
      <div class="small">Channels</div>
      <div id="channels" class="ch-list"></div>
      <div style="margin-top:8px;display:flex;gap:8px"><input id="newChName" placeholder="neuer Kanal" style="flex:1;padding:6px;border-radius:8px;background:transparent;border:1px solid rgba(255,255,255,0.03)" /><div class="btn" id="createCh">Create</div></div>
    </div>
    <div class="card">
      <div class="small">Friend Requests</div>
      <div id="frReq"></div>
    </div>
  </div>
  <div class="main">
    <div class="card composer" id="composer">
      <textarea id="postText" placeholder="Write something... (public/channel/friends only)"></textarea>
      <div style="display:flex;gap:8px;align-items:center;margin-top:8px">
        <label class="btn">Video <input id="videoInput" type="file" accept="video/*" style="display:none" /></label>
        <select id="visibility"><option value="public">Public</option><option value="channel">Channel</option><option value="friends">Friends</option></select>
        <select id="channelSelect"></select>
        <div style="flex:1"></div>
        <div class="btn" id="postBtn">Post</div>
      </div>
      <div id="preview" style="margin-top:8px"></div>
      <div class="small" id="maxNote">Max Upload: 42MB</div>
    </div>

    <div class="feed" id="feed"></div>
  </div>
</div>

<!-- simple modal -->
<div id="modal" style="position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.6);z-index:999"><div style="width:92%;max-width:760px;background:#071018;padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.03)"><div id="modalContent"></div><div style="display:flex;justify-content:flex-end;margin-top:8px"><div class="btn" id="closeModal">Close</div></div></div></div>

<script>
/*
  Design notes / architecture summary (short):
  - Client-only UI in this file supports cross-device sync via an optional relay server (WebSocket).
  - End-to-end encryption (E2EE): Each user holds an asymmetric key pair (RSA-OAEP) stored locally.
    For sharing with friends or channels, symmetric content keys (AES-GCM) are generated per post and
    encrypted with recipients' public keys; server stores only encrypted blobs/metadata.
  - Media blobs stored in IndexedDB (media store) encrypted with the post's content key.
  - Sync: client connects to ws://<RELAY_SERVER>/ and sends encrypted sync messages; server doesn't have keys.
  - Follow / friend request: implemented with friend requests; accepting shares public key to follower.
  - Upload limit: 42MB enforced in client.
  - Mobile: responsive layout + touch-friendly controls.

  Minimal server snippet (Node.js) provided below in comment for deploy. Server must only store encrypted payloads.
*/

// ---------- Config ----------
const RELAY_WS = location.origin.replace(/^http/, 'ws') + '/ws'; // override when deploying relay server
const UPLOAD_LIMIT = 42 * 1024 * 1024; // 42MB

// ---------- Storage Keys ----------
const META_KEY = 'flap_meta_v2';
let META = { users:[], currentUser:null, channels:[], posts:[], friends:[], requests:[] };

// ---------- IndexedDB for media (encrypted blobs) ----------
function openIDB(){ return new Promise((res,rej)=>{ const r=indexedDB.open('flap_media_v2',1); r.onupgradeneeded = e=>{ const db = e.target.result; if(!db.objectStoreNames.contains('media')) db.createObjectStore('media'); }; r.onsuccess=e=>res(e.target.result); r.onerror=e=>rej(e); }); }
function putMedia(id, blob){ return openIDB().then(db=>new Promise((res,rej)=>{ const tx=db.transaction('media','readwrite'); tx.objectStore('media').put(blob,id); tx.oncomplete=()=>res(true); tx.onerror=(e)=>rej(e); })); }
function getMedia(id){ return openIDB().then(db=>new Promise((res,rej)=>{ const tx=db.transaction('media','readonly'); const req = tx.objectStore('media').get(id); req.onsuccess=()=>res(req.result||null); req.onerror=(e)=>rej(e); })); }
function deleteMedia(id){ return openIDB().then(db=>new Promise((res,rej)=>{ const tx=db.transaction('media','readwrite'); const req = tx.objectStore('media').delete(id); req.onsuccess=()=>res(true); req.onerror=e=>rej(e); })); }

// ---------- Local meta load/save ----------
function loadMeta(){ const raw = localStorage.getItem(META_KEY); if(raw) META = JSON.parse(raw); else saveMeta(); }
function saveMeta(){ localStorage.setItem(META_KEY, JSON.stringify(META)); }
function uid(p='id'){ return p+Math.random().toString(36).slice(2,9); }

// ---------- Crypto helpers (Web Crypto) ----------
async function generateKeyPair(){ const kp = await crypto.subtle.generateKey({name:'RSA-OAEP',modulusLength:2048,publicExponent:new Uint8Array([1,0,1]),hash:'SHA-256'}, true, ['encrypt','decrypt']); return kp; }
async function exportPublic(k){ const raw = await crypto.subtle.exportKey('spki', k); return arrayBufferToBase64(raw); }
async function exportPrivate(k){ const raw = await crypto.subtle.exportKey('pkcs8', k); return arrayBufferToBase64(raw); }
async function importPublic(b64){ const ab = base64ToArrayBuffer(b64); return crypto.subtle.importKey('spki', ab, {name:'RSA-OAEP',hash:'SHA-256'}, true, ['encrypt']); }
async function importPrivate(b64){ const ab = base64ToArrayBuffer(b64); return crypto.subtle.importKey('pkcs8', ab, {name:'RSA-OAEP',hash:'SHA-256'}, true, ['decrypt']); }
function arrayBufferToBase64(buf){ const bytes = new Uint8Array(buf); let binary=''; for(let i=0;i<bytes.byteLength;i++) binary += String.fromCharCode(bytes[i]); return btoa(binary); }
function base64ToArrayBuffer(b64){ const binary = atob(b64); const len = binary.length; const bytes = new Uint8Array(len); for(let i=0;i<len;i++) bytes[i]=binary.charCodeAt(i); return bytes.buffer; }
async function generateContentKey(){ return crypto.subtle.generateKey({name:'AES-GCM',length:256}, true, ['encrypt','decrypt']); }
async function exportSymKey(key){ const raw = await crypto.subtle.exportKey('raw', key); return arrayBufferToBase64(raw); }
async function importSymKey(b64){ const ab = base64ToArrayBuffer(b64); return crypto.subtle.importKey('raw', ab, {name:'AES-GCM'}, true, ['encrypt','decrypt']); }
async function encryptWithSym(key, data){ const iv = crypto.getRandomValues(new Uint8Array(12)); const ct = await crypto.subtle.encrypt({name:'AES-GCM',iv}, key, data); return {iv:arrayBufferToBase64(iv.buffer), ct:arrayBufferToBase64(ct)}; }
async function decryptWithSym(key, ivB64, ctB64){ const iv = new Uint8Array(base64ToArrayBuffer(ivB64)); const ct = base64ToArrayBuffer(ctB64); const ab = await crypto.subtle.decrypt({name:'AES-GCM',iv}, key, ct); return new Uint8Array(ab); }
async function encryptKeyForRecipient(pubKey, symKey){ const raw = base64ToArrayBuffer(await exportSymKey(symKey)); const encrypted = await crypto.subtle.encrypt({name:'RSA-OAEP'}, pubKey, raw); return arrayBufferToBase64(encrypted); }
async function decryptKeyWithPrivate(privKey, encB64){ const ab = base64ToArrayBuffer(encB64); const raw = await crypto.subtle.decrypt({name:'RSA-OAEP'}, privKey, ab); return crypto.subtle.importKey('raw', raw, {name:'AES-GCM'}, true, ['encrypt','decrypt']); }

// ---------- Simple UI wiring ----------
const feed = document.getElementById('feed'); const channelsEl = document.getElementById('channels'); const channelSelect = document.getElementById('channelSelect'); const accBox = document.getElementById('accBox'); const syncStatus = document.getElementById('syncStatus');
let ws = null; let wsOpen = false; let myKeyPair = null; let myPubB64 = null; let myPrivB64 = null; let myPrivImported = null;

loadMeta();
(async()=>{
  // Try to import current user's keys if present
  if(META.currentUser){ const u = META.users.find(x=>x.id===META.currentUser); if(u && u.priv){ try{ myPrivImported = await importPrivate(u.priv); myPubB64 = u.pub; myKeyPair = {publicKey:null, privateKey:myPrivImported}; }catch(e){ console.warn('Failed import key',e); } } }
  renderUI();
  connectWS();
})();

function renderUI(){ accBox.innerHTML = '';
  if(META.currentUser){ const u = META.users.find(x=>x.id===META.currentUser); accBox.innerHTML = `<div class="small">${u.name}</div><div class="small">id:${u.id.slice(-6)}</div>`; } else { accBox.innerHTML = `<div class="small">nicht angemeldet</div>`; }
  renderChannels(); renderFeed(); renderRequests(); }

function renderChannels(){ channelsEl.innerHTML=''; channelSelect.innerHTML=''; META.channels.forEach(ch=>{ const d=document.createElement('div'); d.className='ch-item card'; d.textContent = ch.name; d.onclick = ()=>{ selectChannel(ch.id); }; channelsEl.appendChild(d); const opt=document.createElement('option'); opt.value=ch.id; opt.textContent=ch.name; channelSelect.appendChild(opt); }); }

function renderRequests(){ const el=document.getElementById('frReq'); el.innerHTML=''; META.requests.forEach(r=>{ const d=document.createElement('div'); d.className='small'; d.textContent = r.fromName + ' -> ' + r.type; const btnAccept=document.createElement('div'); btnAccept.className='btn'; btnAccept.style.marginLeft='8px'; btnAccept.textContent='Accept'; btnAccept.onclick=()=>acceptRequest(r.id); d.appendChild(btnAccept); el.appendChild(d); }); }

function renderFeed(){ feed.innerHTML=''; const posts = META.posts.slice().sort((a,b)=>b.ts-a.ts); posts.forEach(p=>{ const c=document.createElement('div'); c.className='card'; c.innerHTML = `<div style="display:flex;justify-content:space-between"><div class="small">${p.authorName}</div><div class="small">${new Date(p.ts).toLocaleString()}</div></div><div style="margin-top:8px">${escapeHtml(p.text)}</div><div class="media-slot" data-id='${p.mediaId||''}'></div>`; feed.appendChild(c); if(p.mediaId){ attachEncryptedMedia(c.querySelector('.media-slot'), p); } }); }

async function attachEncryptedMedia(slot, p){ // fetch encrypted blob from server (or local mirror)
  // Try to get local media first
  const blobEnc = await getMedia(p.mediaId).catch(()=>null);
  if(blobEnc){ // decrypt using my private key if intended for me
    try{ const encMeta = JSON.parse(p.enc); // {iv, ct, keyRecipients: [{to,encKeyB64}], alg}
      // find recipient key for me
      const rec = encMeta.keyRecipients.find(r=>r.to===META.currentUser);
      if(rec){ const sym = await decryptKeyWithPrivate(myPrivImported, rec.encKey); const dec = await decryptWithSym(sym, encMeta.iv, p.mediaCt); const blob = new Blob([dec], {type:p.mediaType||'video/mp4'}); const url = URL.createObjectURL(blob); slot.innerHTML = `<video controls src='${url}' style='width:100%;max-height:320px;border-radius:8px'></video>`; }
    }catch(e){ console.warn('cannot decrypt local media', e); }
  } else {
    // Try to download encrypted media from relay (we keep server opaque; client requests via WS)
    if(wsOpen){ ws.send(JSON.stringify({t:'requestMedia', id:p.mediaId, by:META.currentUser})); }
    slot.innerHTML = `<div class='small'>media on server (encrypted)</div>`;
  }
}

// ---------- Authentication & Key management ----------
document.getElementById('openLogin').onclick = ()=>{ showModal(`<h3>Account</h3><input id='uName' placeholder='name' style='width:100%;padding:8px;margin-top:8px' /><div style='display:flex;gap:8px;margin-top:8px'><div class='btn' id='createAcc'>Create</div><div class='btn' id='loginAcc'>Login</div></div>`); document.getElementById('createAcc').onclick = async ()=>{ const n=document.getElementById('uName').value.trim(); if(!n) return alert('name'); const id = uid('u_'); const kp = await generateKeyPair(); const pub = await exportPublic(kp.publicKey); const priv = await exportPrivate(kp.privateKey); META.users.push({id,name:n,pub,priv}); META.currentUser = id; saveMeta(); myPubB64 = pub; myPrivB64 = priv; myPrivImported = await importPrivate(priv); closeModal(); renderUI(); connectWS(); }; document.getElementById('loginAcc').onclick = ()=>{ closeModal(); alert('Login is local: to switch accounts, you must have previously created one in this browser.'); }; };

document.getElementById('keyMgmt').onclick = ()=>{ const u = META.users.find(x=>x.id===META.currentUser); showModal(`<h3>Keys</h3><div class='small'>Public Key (shareable)</div><textarea style='width:100%;height:120px'>${u?u.pub:''}</textarea><div style='margin-top:8px' class='small'>Private key stored locally (not shown)</div>`); };

function showModal(html){ document.getElementById('modalContent').innerHTML = html; document.getElementById('modal').style.display='flex'; }
function closeModal(){ document.getElementById('modal').style.display='none'; }
document.getElementById('closeModal').onclick = closeModal;

// ---------- Channels & posting ----------
document.getElementById('createCh').onclick = ()=>{ const name=document.getElementById('newChName').value.trim(); if(!name) return alert('name'); const ch={id:uid('ch_'),name}; META.channels.push(ch); saveMeta(); renderUI(); };

let pendingFile = null;
document.getElementById('videoInput').onchange = (e)=>{ const f = e.target.files[0]; if(!f) return; if(f.size>UPLOAD_LIMIT) return alert('File too big (max 42MB)'); pendingFile = f; const url = URL.createObjectURL(f); document.getElementById('preview').innerHTML = `<video controls src='${url}' style='width:100%;max-height:220px;border-radius:8px'></video>`; };

// Post flow: create content key, encrypt media, store blob locally encrypted, upload encrypted metadata to relay
document.getElementById('postBtn').onclick = async ()=>{
  const text = document.getElementById('postText').value.trim(); const vis = document.getElementById('visibility').value; const chId = document.getElementById('channelSelect').value;
  if(!text && !pendingFile) return alert('post needs text or media');
  const postId = uid('p_');
  // create content key
  const contentKey = await generateContentKey();
  // export raw for recipient encryption
  const exportedSym = await exportSymKey(contentKey);
  const recipients = [];
  // determine recipients: public-> everyone (we'll encrypt sym with server-held public? For public we encrypt sym with uploader's pub only and mark public=true)
  if(vis==='public'){
    // For public, we encrypt with uploader's key and mark public
    // but to allow cross-device other devices of same user, we simply mark recipients = [me]
    recipients.push(META.currentUser);
  } else if(vis==='friends'){
    // send to accepted friends
    const friends = META.friends.map(f=>f.id); friends.forEach(id=>recipients.push(id));
  } else if(vis==='channel'){
    // channel members: for simplicity, channel is public subscription; we'll mark channel id
    // recipients will be channel (server distributes encrypted blobs encrypted for uploader only; real implementation would require channel member key sharing)
    recipients.push('channel:'+chId);
  }

  // encrypt media with contentKey and store encrypted blob locally (we'll use AES-GCM on the raw file bytes)
  let mediaId = null; let mediaType = null; let encMeta = null; let mediaCtB64 = null;
  if(pendingFile){ mediaId = uid('m_'); mediaType = pendingFile.type || 'video/mp4'; const arr = await pendingFile.arrayBuffer(); const enc = await encryptWithSym(contentKey, new Uint8Array(arr)); // returns iv & ct b64
    mediaCtB64 = enc.ct; encMeta = {iv:enc.iv}; // store encMeta in post (keyRecipients will follow)
    // store encrypted blob in IndexedDB as raw ct bytes (base64 -> Uint8Array)
    const ctBuf = base64ToArrayBuffer(mediaCtB64);
    await putMedia(mediaId, ctBuf);
  }

  // prepare keyRecipients: for each recipient (who has a public key), encrypt exportedSym with their pub
  const keyRecipients = [];
  for(const r of recipients){ if(r.startsWith && r.startsWith('channel:')){ keyRecipients.push({to:r, encKey:null}); continue; } const user = META.users.find(u=>u.id===r); if(user && user.pub){ try{ const pub = await importPublic(user.pub); const encKey = await (async()=>{ const raw = base64ToArrayBuffer(exportedSym); const enc = await crypto.subtle.encrypt({name:'RSA-OAEP'}, pub, raw); return arrayBufferToBase64(enc); })(); keyRecipients.push({to:r, encKey}); }catch(e){ console.warn('failed encrypt sym for', r, e); } } }

  const postMeta = {id:postId, authorId: META.currentUser, authorName: (META.users.find(u=>u.id===META.currentUser)||{}).name||'anon', text, ts:Date.now(), visibility:vis, channelId: chId||null, mediaId, mediaType, enc: JSON.stringify({iv:encMeta.iv, keyRecipients}), mediaCt: mediaCtB64};
  META.posts.push(postMeta); saveMeta(); renderFeed(); // local

  // send encrypted metadata to relay for cross-device visibility (server will not have keys)
  if(wsOpen){ ws.send(JSON.stringify({t:'post', post:postMeta})); }

  // cleanup
  pendingFile = null; document.getElementById('preview').innerHTML=''; document.getElementById('postText').value='';
};

// ---------- Friend requests ----------
function sendFriendRequest(toId){ // create request with my pub key
  const u = META.users.find(x=>x.id===toId); if(!u) return alert('user not found'); const req = {id:uid('r_'), from:META.currentUser, fromName: (META.users.find(u=>u.id===META.currentUser)||{}).name, to:toId, type:'friend'}; META.requests.push(req); saveMeta(); if(wsOpen) ws.send(JSON.stringify({t:'request', req})); renderRequests(); }
async function acceptRequest(id){ const r = META.requests.find(x=>x.id===id); if(!r) return; // when accepting, exchange pub keys (already stored locally in users list if present)
  // we'll just move to friends
  META.friends.push({id:r.from}); META.requests = META.requests.filter(x=>x.id!==id); saveMeta(); renderRequests(); renderUI(); if(wsOpen) ws.send(JSON.stringify({t:'accept', id, by:META.currentUser})); }

// ---------- WebSocket relay (simple) ----------
function connectWS(){ try{ ws = new WebSocket(RELAY_WS); ws.onopen = ()=>{ wsOpen=true; syncStatus.textContent='sync:online'; // register
      ws.send(JSON.stringify({t:'hello', userId:META.currentUser, pub: (META.users.find(u=>u.id===META.currentUser)||{}).pub||null })); // send public key so server can index
    };
    ws.onmessage = async (ev)=>{ try{ const msg = JSON.parse(ev.data); // handle incoming posts/requests/media
        if(msg.t==='post'){ // new post from other device
          META.posts.push(msg.post); saveMeta(); renderFeed(); }
        if(msg.t==='request'){ META.requests.push(msg.req); saveMeta(); renderRequests(); }
        if(msg.t==='media' && msg.id && msg.data){ // server pushed encrypted media bytes (base64)
          const buf = base64ToArrayBuffer(msg.data); // store locally
          await putMedia(msg.id, buf); }
      }catch(e){ console.warn(e); } };
    ws.onclose = ()=>{ wsOpen=false; syncStatus.textContent='sync:offline'; setTimeout(connectWS,3000); };
    ws.onerror = ()=>{ wsOpen=false; syncStatus.textContent='sync:error'; ws.close(); };
  }catch(e){ console.warn('ws err',e); }
}

// ---------- Helpers ----------
function escapeHtml(s){ return String(s||'').replace(/[&<>]/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;'}[c])); }
function arrayBufferToBase64(buf){ const bytes = new Uint8Array(buf); let binary=''; for(let i=0;i<bytes.byteLength;i++) binary+=String.fromCharCode(bytes[i]); return btoa(binary); }
function base64ToArrayBuffer(b64){ const binary = atob(b64); const len = binary.length; const bytes = new Uint8Array(len); for(let i=0;i<len;i++) bytes[i]=binary.charCodeAt(i); return bytes.buffer; }

// ---------- Minimal server snippet (Node.js + ws) ----------
/*
// Save as relay_server.js (example). IMPORTANT: This server stores only encrypted blobs/metadata; it cannot decrypt content.
const http = require('http'); const WebSocket = require('ws'); const fs = require('fs'); const path = require('path');
const server = http.createServer((req,res)=>res.end('FLAP Relay'));
const wss = new WebSocket.Server({server});
const USERS = {}; // id -> ws
wss.on('connection', ws=>{
  ws.on('message', msg=>{ try{ const m = JSON.parse(msg); if(m.t==='hello'){ if(m.userId) USERS[m.userId]=ws; } if(m.t==='post'){ // broadcast to all other devices (simple)
        Object.values(USERS).forEach(s=>{ if(s!==ws) s.send(JSON.stringify({t:'post', post:m.post})); }); }
      if(m.t==='request'){ Object.values(USERS).forEach(s=>{ if(s!==ws) s.send(JSON.stringify({t:'request', req:m.req})); }); }
      if(m.t==='requestMedia'){ // client asking for media; if server has stored encrypted blob file, send as base64
        const id = m.id; const p = path.join(__dirname,'media',id+'.bin'); if(fs.existsSync(p)){ const b = fs.readFileSync(p); const b64 = b.toString('base64'); ws.send(JSON.stringify({t:'media', id, data: b64})); }
      }
    }catch(e){ console.warn(e); } });
});
server.listen(8080);
*/

// ---------- Final notes ----------
// This client implements a privacy-forward cross-device sync approach: all media and metadata are encrypted
// client-side. The relay server only stores and forwards encrypted payloads. For GDPR compliance, ensure
// users can request deletion and the server removes blobs; you must implement server-side deletion endpoints.

</script>
</body>
</html>
